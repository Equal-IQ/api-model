/**
 * Non-autogenerated XML markup utilities
 * Shared between contract-tinkering (backend) and frontend
 *
 * DO NOT add to smithy-build.json - this file is maintained manually
 */

import { ContractVariable, ContractVariableType } from './index'
import {
  VariableTagAttributes,
  ParsedVariableTag,
  XmlParseOptions,
  ValidationResult
} from './xml-types'

/**
 * Regular expression for matching <variable> tags
 * Matches: <variable type="..." id="..." [instance="..."] [level="..."]>...</variable>
 */
export const VARIABLE_TAG_REGEX = /<variable\b([^>]*)>([\s\S]*?)<\/variable>/gi

/**
 * Regular expression for extracting attributes from tag
 */
export const ATTRIBUTE_REGEX = /(\w+)=["'](.*?)["']/g

/**
 * Parse a single <variable> tag and extract attributes
 *
 * @param tagMatch - RegExp match array from VARIABLE_TAG_REGEX
 * @returns Parsed tag data or null if invalid
 */
export function parseVariableTag(tagMatch: RegExpMatchArray): ParsedVariableTag | null {
  if (!tagMatch || tagMatch.length < 3) return null

  const fullMatch = tagMatch[0]
  const rawAttrs = tagMatch[1]
  const innerText = tagMatch[2].trim()

  const attrs: Partial<VariableTagAttributes> = {}
  let attrMatch: RegExpExecArray | null
  const attrRegex = new RegExp(ATTRIBUTE_REGEX.source, ATTRIBUTE_REGEX.flags)

  while ((attrMatch = attrRegex.exec(rawAttrs)) !== null) {
    const [, key, value] = attrMatch
    if (key === 'type') {
      attrs.type = value as ContractVariableType
    } else if (key === 'id') {
      attrs.id = value
    } else if (key === 'instance') {
      attrs.instance = value
    } else if (key === 'level') {
      attrs.level = parseInt(value, 10)
    }
  }

  if (!attrs.type || !attrs.id) return null

  return {
    attributes: attrs as VariableTagAttributes,
    innerText,
    fullMatch,
    startIndex: tagMatch.index || 0,
    endIndex: (tagMatch.index || 0) + fullMatch.length
  }
}

/**
 * Build a <variable> tag string from attributes and content
 *
 * @param attributes - Tag attributes
 * @param content - Inner text content
 * @returns Complete XML tag string
 */
export function buildVariableTag(
  attributes: VariableTagAttributes,
  content: string
): string {
  let tag = `<variable type="${attributes.type}" id="${attributes.id}"`

  if (attributes.instance) {
    tag += ` instance="${attributes.instance}"`
  }

  if (attributes.level !== undefined) {
    tag += ` level="${attributes.level}"`
  }

  tag += `>${content}</variable>`
  return tag
}

/**
 * Parse all <variable> tags in text
 *
 * @param text - Text containing variable tags
 * @param options - Parsing options
 * @returns Array of parsed tags in document order
 */
export function parseAllVariableTags(
  text: string,
  options?: XmlParseOptions
): ParsedVariableTag[] {
  const tags: ParsedVariableTag[] = []
  const regex = new RegExp(VARIABLE_TAG_REGEX.source, VARIABLE_TAG_REGEX.flags)
  let match: RegExpExecArray | null

  while ((match = regex.exec(text)) !== null) {
    const parsed = parseVariableTag(match)
    if (parsed) {
      // If not preserving instances, re-count them
      if (options?.preserveInstance === false) {
        const instanceCount = tags.filter(t => t.attributes.id === parsed.attributes.id).length
        parsed.attributes.instance = String(instanceCount + 1)
      }
      tags.push(parsed)
    }
  }

  return tags
}

/**
 * Validate that variable tag attributes match the ContractVariable data
 *
 * @param tag - Parsed variable tag
 * @param variable - Contract variable data
 * @returns Validation result with any errors
 */
export function validateVariableTag(
  tag: ParsedVariableTag,
  variable: ContractVariable
): ValidationResult {
  const errors: string[] = []

  if (tag.attributes.type !== variable.type) {
    errors.push(`Type mismatch: tag=${tag.attributes.type}, variable=${variable.type}`)
  }

  if (tag.attributes.id !== variable.id) {
    errors.push(`ID mismatch: tag=${tag.attributes.id}, variable=${variable.id}`)
  }

  if (tag.attributes.level !== undefined && variable.level !== undefined) {
    if (tag.attributes.level !== variable.level) {
      errors.push(`Level mismatch: tag=${tag.attributes.level}, variable=${variable.level}`)
    }
  }

  // Only external_term should have level attribute
  if (tag.attributes.level !== undefined && tag.attributes.type !== 'external_term') {
    errors.push(`Level attribute should only be present for external_term type`)
  }

  return {
    isValid: errors.length === 0,
    errors
  }
}

/**
 * Convert variable tag attributes to HTML data-* attributes
 * Useful for frontend rendering
 *
 * @param attrs - Variable tag attributes
 * @returns Object with data-* attribute names and values
 */
export function variableAttrsToDataAttrs(attrs: VariableTagAttributes): Record<string, string> {
  const dataAttrs: Record<string, string> = {
    'data-type': attrs.type,
    'data-id': attrs.id
  }

  if (attrs.instance) {
    dataAttrs['data-instance'] = attrs.instance
  }

  if (attrs.level !== undefined) {
    dataAttrs['data-level'] = String(attrs.level)
  }

  return dataAttrs
}

/**
 * Convert HTML data-* attributes back to variable tag attributes
 * Useful for reading frontend-rendered elements
 *
 * @param dataAttrs - Object with data-* attributes
 * @returns Variable tag attributes or null if required fields missing
 */
export function dataAttrsToVariableAttrs(
  dataAttrs: Record<string, string>
): VariableTagAttributes | null {
  const type = dataAttrs['data-type'] as ContractVariableType
  const id = dataAttrs['data-id']

  if (!type || !id) return null

  const attrs: VariableTagAttributes = { type, id }

  if (dataAttrs['data-instance']) {
    attrs.instance = dataAttrs['data-instance']
  }

  if (dataAttrs['data-level']) {
    attrs.level = parseInt(dataAttrs['data-level'], 10)
  }

  return attrs
}

/**
 * Escape HTML special characters
 * Works in both browser and Node.js environments
 *
 * @param text - Text to escape
 * @returns HTML-safe text
 */
export function escapeHtml(text: string): string {
  // Check if we're in a browser environment
  if (typeof document !== 'undefined') {
    const div = document.createElement('div')
    div.textContent = text
    return div.innerHTML
  }

  // Fallback for Node.js environment
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;')
}

/**
 * Count instances of each variable ID in text
 * Useful for understanding markup density
 *
 * @param text - Text containing variable tags
 * @returns Map of variable ID to occurrence count
 */
export function countVariableInstances(text: string): Map<string, number> {
  const counts = new Map<string, number>()
  const tags = parseAllVariableTags(text)

  for (const tag of tags) {
    const id = tag.attributes.id
    counts.set(id, (counts.get(id) || 0) + 1)
  }

  return counts
}

/**
 * Get all unique variable IDs from text
 *
 * @param text - Text containing variable tags
 * @returns Array of unique variable IDs
 */
export function getUniqueVariableIds(text: string): string[] {
  const ids = new Set<string>()
  const tags = parseAllVariableTags(text)

  for (const tag of tags) {
    ids.add(tag.attributes.id)
  }

  return Array.from(ids)
}
